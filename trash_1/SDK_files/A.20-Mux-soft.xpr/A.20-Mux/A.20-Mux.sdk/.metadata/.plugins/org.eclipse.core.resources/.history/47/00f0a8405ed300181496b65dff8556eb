/*
 * Simple DHCP Client
 * License : BSD
 * Author : Samuel Jacob (samueldotj@gmail.com)
 */
/* #include <sys/types.h> */
/* #include <sys/socket.h> */
/* #include <sys/ioctl.h> */
/* #include <net/ethernet.h> */
/* #include <net/if.h> */
/* #ifndef __linux__ */
/* #include <net/if_dl.h> */
/* #endif */
/* #include <netinet/in.h> */
/* #include <netinet/ip.h> */

/* #define __FAVOR_BSD */
/* #include <netinet/udp.h> */
/* #include <pcap.h> */
/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */
/* #include <unistd.h> */
/* #include <errno.h> */
/* #include <ifaddrs.h> */

//typedef u_int32_t ip4_t;


// Things for NISHIPhy
// #define IBUFLEN 128

// IOModule custom offsets
#define CUSTOM_REG_OFFSET 0x20

// Unions are sick af
// Define a 5-byte object
union cuteStuff {
  u32 u32View;
  char8 strView[5];
};



#define DHCP_CHADDR_LEN 16
#define DHCP_SNAME_LEN  64
#define DHCP_FILE_LEN   128

/*
 * http://www.tcpipguide.com/free/t_DHCPMessageFormat.htm
 */
typedef struct dhcp
{
  u8 opcode;
  u8 htype;
  u8 hlen;
  u8 hops;
  u32 xid;
  u16 secs;
  u16 flags;
  u32 ciaddr;
  u32 yiaddr;
  u32 siaddr;
  u32 giaddr;
  u8 chaddr[DHCP_CHADDR_LEN];
  char        bp_sname[DHCP_SNAME_LEN];
  char        bp_file[DHCP_FILE_LEN];
  u32 magic_cookie;
  u8 bp_options[0];
} dhcp_t;

#define DHCP_BOOTREQUEST                    1
#define DHCP_BOOTREPLY                      2

#define DHCP_HARDWARE_TYPE_10_EHTHERNET     1

#define MESSAGE_TYPE_PAD                    0
#define MESSAGE_TYPE_REQ_SUBNET_MASK        1
#define MESSAGE_TYPE_ROUTER                 3
#define MESSAGE_TYPE_DNS                    6
#define MESSAGE_TYPE_DOMAIN_NAME            15
#define MESSAGE_TYPE_REQ_IP                 50
#define MESSAGE_TYPE_DHCP                   53
#define MESSAGE_TYPE_PARAMETER_REQ_LIST     55
#define MESSAGE_TYPE_END                    255

#define DHCP_OPTION_DISCOVER                1
#define DHCP_OPTION_OFFER                   2
#define DHCP_OPTION_REQUEST                 3
#define DHCP_OPTION_PACK                    4

#define DHCP_SERVER_PORT    67
#define DHCP_CLIENT_PORT    68

#define DHCP_MAGIC_COOKIE   0x63825363

u32 ip;
char dhcpDone = 0;

static int get_mac_address(u8 *mac) {

  // Assumes that mac is a 6 byte buffer....

  // For the NIFTPhy, the mac is built from the device dna
  *mac = (u8)( *( XPAR_IOMODULE_0_IO_BASEADDR | CUSTOM_REG_OFFSET | 0x04));
  *(mac + 2) = (u8)( *( XPAR_IOMODULE_0_IO_BASEADDR | CUSTOM_REG_OFFSET | 0x08));

  // XXX Check for IOModule failures...
  return 0;
}

/*
 * Return checksum for the given data.
 * Copied from FreeBSD
 */
static unsigned short in_cksum(unsigned short *addr, int len)
{
    register int sum = 0;
    u_short answer = 0;
    register u_short *w = addr;
    register int nleft = len;
    /*
     * Our algorithm is simple, using a 32 bit accumulator (sum), we add
     * sequential 16 bit words to it, and at the end, fold back all the
     * carry bits from the top 16 bits into the lower 16 bits.
     */
    while (nleft > 1)
    {
        sum += *w++;
        nleft -= 2;
    }
    /* mop up an odd byte, if necessary */
    if (nleft == 1)
    {
        *(u_char *)(&answer) = *(u_char *) w;
        sum += answer;
    }
    /* add back carry outs from top 16 bits to low 16 bits */
    sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
    sum += (sum >> 16);             /* add carry */
    answer = ~sum;              /* truncate to 16 bits */
    return (answer);
}


/*
 * This function will be called for any incoming DHCP responses
 */
static void dhcp_input(dhcp_t *dhcp)
{
    if (dhcp->opcode != DHCP_OPTION_OFFER)
        return;

    /* Get the IP address given by the server */
    ip = Xil_Ntohl(dhcp->yiaddr);

    /* We are done - lets break the loop */
    // pcap_breakloop(pcap_handle);
    dhcpDone = 1;
}

/*
 * UDP packet handler
 */
static void udp_input(struct udphdr * udp_packet)
{
    /* Check if there is a response from DHCP server by checking the source Port */
    if (Xil_Ntohs(udp_packet->uh_sport) == DHCP_SERVER_PORT)
        dhcp_input((dhcp_t *)((char *)udp_packet + sizeof(struct udphdr)));
}

/*
 * IP Packet handler
 */
static void ip_input(struct ip * ip_packet)
{
    /* Care only about UDP - since DHCP sits over UDP */
    if (ip_packet->ip_p == IPPROTO_UDP)
        udp_input((struct udphdr *)((char *)ip_packet + sizeof(struct ip)));
}

/*
 * Ethernet packet handler
 */
static void ether_input(const u8 *frame)
{
    struct ether_header *eframe = (struct ether_header *)frame;

//    PRINT(VERBOSE_LEVEL_DEBUG, "Received a frame with length of [%d]", header->len);

    /* if (program_verbose_level == VERBOSE_LEVEL_DEBUG) */
    /*     print_packet(frame, header->len); */

    if (Xil_Htons(eframe->ether_type) == ETHERTYPE_IP)
        ip_input((struct ip *)(frame + sizeof(struct ether_header)));
}

/*
 * Ethernet output handler - Fills appropriate bytes in ethernet header
 */
static void ether_output(u8 *frame, u8 *mac, int len)
{
    int result;
    struct ether_header *eframe = (struct ether_header *)frame;

    memcpy(eframe->ether_shost, mac, ETHER_ADDR_LEN);
    memset(eframe->ether_dhost, -1,  ETHER_ADDR_LEN);
    eframe->ether_type = Xil_Htons(ETHERTYPE_IP);

    len = len + sizeof(struct ether_header);

    result = NIFT_emitFrame(frame, len);
}

/*
 * IP Output handler - Fills appropriate bytes in IP header
 */
static void ip_output(struct ip *ip_header, int *len)
{
    *len += sizeof(struct ip);

    ip_header->ip_hl = 5;
    ip_header->ip_v = IPVERSION;
    ip_header->ip_tos = 0x10;
    ip_header->ip_len = Xil_Htons(*len);
    ip_header->ip_id = Xil_Htons(0xffff);
    ip_header->ip_off = 0;
    ip_header->ip_ttl = 16;
    ip_header->ip_p = IPPROTO_UDP;
    ip_header->ip_sum = 0;
    ip_header->ip_src.s_addr = 0;
    ip_header->ip_dst.s_addr = 0xFFFFFFFF;

    ip_header->ip_sum = in_cksum((unsigned short *) ip_header, sizeof(struct ip));
}

/*
 * UDP output - Fills appropriate bytes in UDP header
 */
static void udp_output(struct udphdr *udp_header, int *len)
{
    if (*len & 1)
        *len += 1;
    *len += sizeof(struct udphdr);

    udp_header->uh_sport = Xil_Htons(DHCP_CLIENT_PORT);
    udp_header->uh_dport = Xil_Htons(DHCP_SERVER_PORT);
    udp_header->uh_ulen = Xil_Htons(*len);
    udp_header->uh_sum = 0;
}

/*
 * DHCP output - Just fills DHCP_BOOTREQUEST
 */
static void dhcp_output(dhcp_t *dhcp, u_int8_t *mac, int *len)
{
    *len += sizeof(dhcp_t);
    memset(dhcp, 0, sizeof(dhcp_t));

    dhcp->opcode = DHCP_BOOTREQUEST;
    dhcp->htype = DHCP_HARDWARE_TYPE_10_EHTHERNET;
    dhcp->hlen = 6;
    memcpy(dhcp->chaddr, mac, DHCP_CHADDR_LEN);

    dhcp->magic_cookie = Xil_Htonl(DHCP_MAGIC_COOKIE);
}

/*
 * Adds DHCP option to the bytestream
 */
static int fill_dhcp_option(u_int8_t *packet, u_int8_t code, u_int8_t *data, u_int8_t len)
{
    packet[0] = code;
    packet[1] = len;
    memcpy(&packet[2], data, len);

    return len + (sizeof(u_int8_t) * 2);
}

/*
 * Fill DHCP options
 */
static int fill_dhcp_discovery_options(dhcp_t *dhcp)
{
    int len = 0;
    u32 req_ip;
    u8 parameter_req_list[] = {MESSAGE_TYPE_REQ_SUBNET_MASK, MESSAGE_TYPE_ROUTER, MESSAGE_TYPE_DNS, MESSAGE_TYPE_DOMAIN_NAME};
    u8 option;

    option = DHCP_OPTION_DISCOVER;
    len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_DHCP, &option, sizeof(option));
    req_ip = Xil_Htonl(0xc0a8010a);
    len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_REQ_IP, (u8 *)&req_ip, sizeof(req_ip));
    len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_PARAMETER_REQ_LIST, (u8 *)&parameter_req_list, sizeof(parameter_req_list));
    option = 0;
    len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_END, &option, sizeof(option));

    return len;
}

/*
 * Send DHCP DISCOVERY packet
 */
static int dhcp_discovery(u8 *mac)
{
    int len = 0;
    u_char packet[4096];
    struct udphdr *udp_header;
    struct ip *ip_header;
    dhcp_t *dhcp;

//    PRINT(VERBOSE_LEVEL_INFO, "Sending DHCP_DISCOVERY");

    ip_header = (struct ip *)(packet + sizeof(struct ether_header));
    udp_header = (struct udphdr *)(((char *)ip_header) + sizeof(struct ip));
    dhcp = (dhcp_t *)(((char *)udp_header) + sizeof(struct udphdr));

    len = fill_dhcp_discovery_options(dhcp);
    dhcp_output(dhcp, mac, &len);
    udp_output(udp_header, &len);
    ip_output(ip_header, &len);
    ether_output(packet, mac, len);
    return 0;
}

int main(int argc, char *argv[])
{
    int result;
    u8 mac[6];

    /* Get the MAC address of the interface */
    result = get_mac_address(mac);
    if (result);
    // XXX

    ip = 0;
   
    /* Listen untill the DHCP OFFER comes */
    /* If it doesn't come after some number of frames, ask again */
    while(!dhcpDone) {

      // Send DHCP DISCOVERY packet
      result = dhcp_discovery(mac);
      if(result)
	break;

      // Intake 100 frames, if none are offers, ask again.
      result = 100;
      
      // NIFT_intakeFrame() will block until it gets a full frame for you
      // pulls frames out of the hardware FIFO via the FSL
      while(!dhcpDone && --result > 0)

	// Get a frame
	frame = NIFT_intakeFrame();

        // Attempt to parse it
	ether_input(frame);

	// Destroy this frame
	free(frame);
    }

    // Die.
    if(!dhcpDone) {
      return;
    }

    // Live!
    print("I have been validated as a human: ");
    putnum(ip & 0x000F);
    print(".");
    putnum((ip >> 4) & 0x000F);
    print(".");
    putnum((ip >> 8) & 0x000F);
    print(".");
    putnum((ip >> 12) & 0x000F);
    print("\n");
}

