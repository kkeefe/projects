/*
 * Simple DHCP Client
 * License : BSD
 * Author : Samuel Jacob (samueldotj@gmail.com)
 */
/* #include <sys/types.h> */
/* #include <sys/socket.h> */
/* #include <sys/ioctl.h> */
/* #include <net/ethernet.h> */
/* #include <net/if.h> */
/* #ifndef __linux__ */
/* #include <net/if_dl.h> */
/* #endif */
/* #include <netinet/in.h> */
/* #include <netinet/ip.h> */

/* #define __FAVOR_BSD */
/* #include <netinet/udp.h> */
/* #include <pcap.h> */
/* #include <stdio.h> */
/* #include <stdlib.h> */
/* #include <string.h> */
/* #include <unistd.h> */
/* #include <errno.h> */
/* #include <ifaddrs.h> */


// Includes for ublaze
//#include <stdio.h>
#include "platform.h"
//#include "xil_printf.h"
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <malloc.h>
#include <string.h>
/* Lets see which ones of these actually work */
#include "xparameters.h"
#include "mb_interface.h"
#include "fsl.h"
#include "xil_types.h"
#include "xil_io.h"

// Registers from RegMap.vhd
#define INTERNAL_OFFSET 0x000
#define LAPPD_OFFSET 0x100
#define NBIC_OFFSET 0x200

#define STATUS_OFFSET 0x004

#define REG_INTERNAL_VERSION 0x000
#define REG_INTERNAL_DNA_LOW 0x008
#define REG_INTERNAL_DNA_HIGH 0x010
#define REG_INTERNAL_EFUSE 0x018
#define REG_INTERNAL_SCRATCH 0x020

// These are already in network order, so you can just blast away
#define REG_LAPPD_SRCMAC_LOW 0x000
#define REG_LAPPD_SRCMAC_HIGH 0x008
#define REG_LAPPD_SRCIP 0x010

#define REG_NBIC_DESTMAC_LOW 0x000
#define REG_NBIC_DESTMAC_HIGH 0x008
#define REG_NBIC_DESTIP 0x010
// Source port is low u16, destination port is high u16
#define REG_NBIC_PORTS 0x018

// Use convention where macros are uppercase
// Notice critical proliferation of parenthesis
#define NISHI_REG_READ(into, where) ((into) = *( (u32 *)(XPAR_IOMODULE_0_IO_BASEADDR | (where))) );
#define NISHI_REG_WRITE(where, what) ( *( (u32 *)(XPAR_IOMODULE_0_IO_BASEADDR | (where))) = (what) );

#define DHCP_CHADDR_LEN 16
#define DHCP_SNAME_LEN  64
#define DHCP_FILE_LEN   128

/*
 * http://www.tcpipguide.com/free/t_DHCPMessageFormat.htm
 */
typedef u_int32_t ip4_t;

typedef struct dhcp
{
    u_int8_t    opcode;
    u_int8_t    htype;
    u_int8_t    hlen;
    u_int8_t    hops;
    u_int32_t   xid;
    u_int16_t   secs;
    u_int16_t   flags;
    ip4_t       ciaddr;
    ip4_t       yiaddr;
    ip4_t       siaddr;
    ip4_t       giaddr;
    u_int8_t    chaddr[DHCP_CHADDR_LEN];
    char        bp_sname[DHCP_SNAME_LEN];
    char        bp_file[DHCP_FILE_LEN];
    uint32_t    magic_cookie;
    u_int8_t    bp_options[0];
} dhcp_t;

#define DHCP_BOOTREQUEST                    1
#define DHCP_BOOTREPLY                      2

#define DHCP_HARDWARE_TYPE_10_EHTHERNET     1

#define MESSAGE_TYPE_PAD                    0
#define MESSAGE_TYPE_REQ_SUBNET_MASK        1
#define MESSAGE_TYPE_ROUTER                 3
#define MESSAGE_TYPE_DNS                    6
#define MESSAGE_TYPE_DOMAIN_NAME            15
#define MESSAGE_TYPE_REQ_IP                 50
#define MESSAGE_TYPE_DHCP                   53
#define MESSAGE_TYPE_SELECTED_SERVER        54
#define MESSAGE_TYPE_PARAMETER_REQ_LIST     55
#define MESSAGE_TYPE_END                    255

#define DHCP_OPTION_DISCOVER                1
#define DHCP_OPTION_OFFER                   2
#define DHCP_OPTION_REQUEST                 3
#define DHCP_OPTION_DECLINE                 4
#define DHCP_OPTION_ACK                     5
#define DHCP_OPTION_NAK                     6

// wtf is this, guy?
//#define DHCP_OPTION_PACK                    4

#define DHCP_SERVER_PORT    67
#define DHCP_CLIENT_PORT    68

#define DHCP_MAGIC_COOKIE   0x63825363

/*  
 * KC 10/18/18
 *
 * This is just quick and dirty.  I've pasted from the standard POSIX/libc headers
 * And changed wonky typedef things to just bare types.
 *
 * Many of these header files look like they can be imported verbatim, though
 * somewhat simplified.
 *
 */

/* Things from various header files that are needed for ethernet, ip, and udp */
/* These were things that I didn't look hard for because I know what they are... */
#define ETH_ALEN 6
#define IPVERSION 4

// From: net/ethernet.h
struct ether_header
{
  u_int8_t  ether_dhost[ETH_ALEN];	/* destination eth addr	*/
  u_int8_t  ether_shost[ETH_ALEN];	/* source ether addr	*/
  u_int16_t ether_type;		        /* packet type ID field	*/
} __attribute__ ((__packed__));

#define	ETHERTYPE_IP		0x0800		/* IP */
#define	ETHER_ADDR_LEN	ETH_ALEN                 /* size of ethernet addr */
#define	ETHERTYPE_ARP		0x0806		/* Address resolution */

// From: netinet/in.h
typedef u_int32_t in_addr_t;

struct in_addr
{  
  in_addr_t s_addr;
}; // __attribute__ ((aligned(4)));

#define IPPROTO_UDP 17

// From: netinet/ip.h
/*
 * Definitions for internet protocol version 4.
 * Per RFC 791, September 1981.
 */

/*
 * Structure of an internet header, naked of options.
 */
/* Note, this is not what LITTLE_ENDIAN is in the POSIX/Linux headers... */
// But the uBlaze is little endian */
#define __LITTLE_ENDIAN 666
#define __BYTE_ORDER __LITTLE_ENDIAN

#define	IP_RF 0x8000			/* reserved fragment flag */
#define	IP_DF 0x4000			/* dont fragment flag */
#define	IP_MF 0x2000			/* more fragments flag */
#define	IP_OFFMASK 0x1fff		/* mask for fragmenting bits */

struct ip
  {
#if __BYTE_ORDER == __LITTLE_ENDIAN
    unsigned int ip_hl:4;		/* header length */
    unsigned int ip_v:4;		/* version */
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
    unsigned int ip_v:4;		/* version */
    unsigned int ip_hl:4;		/* header length */
#endif
    u_int8_t ip_tos;			/* type of service */
    u_short ip_len;			/* total length */
    u_short ip_id;			/* identification */
    u_short ip_off;			/* fragment offset field */
    u_int8_t ip_ttl;			/* time to live */
    u_int8_t ip_p;			/* protocol */
    u_short ip_sum;			/* checksum */
    struct in_addr ip_src, ip_dst;	/* source and dest address */
};

// From: netinet/udp.h
/* UDP header as specified by RFC 768, August 1980. */

struct udphdr
{
  __extension__ union
  {
    struct
    {
      u_int16_t uh_sport;		/* source port */
      u_int16_t uh_dport;		/* destination port */
      u_int16_t uh_ulen;		/* udp length */
      u_int16_t uh_sum;		/* udp checksum */
    };
    struct
    {
      u_int16_t source;
      u_int16_t dest;
      u_int16_t len;
      u_int16_t check;
    };
  };
};

//
// Now we import lowlevel FSL ether reads and writes from Kurtis
//

// From: ethPackets.h

// Maximum Ethernet frame size, excluding checksum,
// which is handled in the firmware rather than here.
//
// This DOES NOT divide evenly by 4...
#define MAX_PACKET_SIZE 1514
// STILL having memory issues...
//#define MAX_PACKET_SIZE 752
// Note this needs to /4 evenly.  It does: 188

// Ethernet Frame
#define ETH_HEADER_SIZE 14
struct EthFrame {

  // Start porting this over to standard stuff
  struct ether_header eheader;
  u8  payload[MAX_PACKET_SIZE - ETH_HEADER_SIZE];
} __attribute__ ((aligned(2)));


// From: linux/if_arp.h
#define	ARPOP_REQUEST	1		/* ARP request			*/
#define	ARPOP_REPLY	2		/* ARP reply			*/
#define ARPHRD_ETHER 	1		/* Ethernet 10Mbps		*/

// I think this means big endian...
typedef u16 __be16;

struct arphdr {
	__be16		ar_hrd;		/* format of hardware address	*/
	__be16		ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	__be16		ar_op;		/* ARP opcode (command)		*/
  //#if 0
	 /*
	  *	 Ethernet looks like this : This bit is variable sized however...
	  */
	unsigned char		ar_sha[ETH_ALEN];	/* sender hardware address	*/
	unsigned char		ar_sip[4];		/* sender IP address		*/
	unsigned char		ar_tha[ETH_ALEN];	/* target hardware address	*/
	unsigned char		ar_tip[4];		/* target IP address		*/
  //#endif
};

// From: ethMain.c

// Buffers for input data
u8 *gInboundData;
struct EthFrame *gInboundFrame;

// Variables for tracking incoming data buffer positions and status
u32 gInboundWordPos = 0;
u32 gCompletePacket = 0;
u32 *gpInboundFrame;

// Now some internal structures I use for keeping track of myself
struct NIFT_ip {

  u8 mac[6];
  ip4_t ip;
  ip4_t dhcpserver;
  ip4_t gateway;
  ip4_t subnet_mask;
  u8 configured;
  
};

// KC 10/20/18
//
// Technically, this should be a linked list of arp entries.
// They should be sorted as new entries are added, so that
// lookups are log N
//
// Super overkill ;)
//
struct NIFT_arp {

  struct in_addr ipaddr;
  u8 nmac[6];
};

// Support a maximum of 10 devices for now
struct NIFT_ip NIFT_ipsystem;
struct NIFT_arp NIFT_arpTable[10];
  
void resetFrame(void) {
  gInboundWordPos = 0;
  gCompletePacket = 0;
  memset((void *) gInboundData, 0, MAX_PACKET_SIZE);
  gpInboundFrame = (u32 *) gInboundData;
}

// Hax to place the ethernet payload itself on a 4-byte alignment
#define HAX 2

void initMemory() {

  gInboundData = (u8 *) memalign(4, MAX_PACKET_SIZE + HAX);
  if(!gInboundData)
    exit(2);
  
  // KC 9/13/18 - why are we advancing 2 pointer widths?
  // A: Because the ethernet PAYLOAD must sit on a 4-byte aligned boundary
  //    or else everything else is fucked.
  //
  gInboundData += HAX;
  gInboundFrame = (struct EthFrame *) gInboundData;
  resetFrame();
}

// KC 10/18/18: completely mysterious black box functions...
void clearLast() {
	u32 msrData = mfmsr();
	msrData &= ~0x10;
	mtmsr(msrData);
}

// Reads a single word off of a given channel
// KC 10/18/18: changed to a single channel for now.
// later, abstract this.
void readFsl(void) {

  u32 tempInvalid = 0;
  u32 tempLast = 0;
  u32 tempData = 0;
  //The standard bogus workaround until we figure out how
  //to get getdfslx to work.

  getfslx(tempData, 0, FSL_NONBLOCKING);

  // KC: guess this is checking for error conditionsa
  fsl_isinvalid(tempInvalid);
  fsl_iserror(tempLast);
  
  // Copy the data and update the word position if data was good
  if (!tempInvalid) {
    memcpy(gpInboundFrame, &tempData, 4);

    // If the word position is at the maximum position, don't update...
    // KC: why are we keeping a value that is always 1/4 of another value?
    //     switching to bitshift for speed 
    if (gInboundWordPos < MAX_PACKET_SIZE / 4) {
      ++gInboundWordPos; //++;
      ++gpInboundFrame; //++;
    }
  }
  
  // Update the last flag
  if (tempLast) {
    gCompletePacket = 1;
    clearLast();
  }
}

void sendFrame(u8 *frame, u32 byteSize) {

  u32 defaultWords;
  u32 finalWord = 0;
  u8 residue;
  
  defaultWords = (byteSize >> 2);
  residue = (u8)(byteSize - (defaultWords << 2));
  
  if(!residue) {
    --defaultWords;
    memcpy(&finalWord, frame + byteSize - 4, 4);
  }
  else
    memcpy(&finalWord, frame + byteSize - 4, residue);

  // Put all the default words
  // Recycle: byteSize
  u32 tmp = 0;
  while(tmp < defaultWords) {

    memcpy(&byteSize, frame + tmp * 4, 4);
    putfslx(byteSize, 0, FSL_DEFAULT);
    ++tmp;
  }

  // Now put the final word
  putfslx(finalWord, 0, FSL_CONTROL);
}

/// End Kurtis/Croker FSL routines

/// My routines

// This will block until a frame is read.
void NIFT_intakeFrame(void) {

  // This loads a frame
  while(!gCompletePacket)
    readFsl();
}


u32 my_ip_addr;
char dhcpDone; // = 0;

static int get_mac_address(u8 *mac) {

  u32 derp;

  NISHI_REG_READ(derp, INTERNAL_OFFSET | REG_INTERNAL_DNA_LOW);
  memcpy(mac, &derp, 2);

  NISHI_REG_READ(derp, INTERNAL_OFFSET | REG_INTERNAL_DNA_HIGH);
  memcpy(mac + 2, &derp, 4);

  // XXX Check for IOModule failures...
  return 0;
}

/*
 * Return checksum for the given data.
 * Copied from FreeBSD
 */
static unsigned short in_cksum(unsigned short *addr, int len)
{
    register int sum = 0;
    u_short answer = 0;
    register u_short *w = addr;
    register int nleft = len;
    /*
     * Our algorithm is simple, using a 32 bit accumulator (sum), we add
     * sequential 16 bit words to it, and at the end, fold back all the
     * carry bits from the top 16 bits into the lower 16 bits.
     */
    while (nleft > 1)
    {
        sum += *w++;
        nleft -= 2;
    }
    /* mop up an odd byte, if necessary */
    if (nleft == 1)
    {
        *(u_char *)(&answer) = *(u_char *) w;
        sum += answer;
    }
    /* add back carry outs from top 16 bits to low 16 bits */
    sum = (sum >> 16) + (sum & 0xffff);     /* add hi 16 to low 16 */
    sum += (sum >> 16);             /* add carry */
    answer = ~sum;              /* truncate to 16 bits */
    return (answer);
}


/*
 * This function will be called for any incoming DHCP responses
 */
static void dhcp_input(dhcp_t *dhcp) {

  u8 *ptr;

  // There could be something else making DHCP requests...
  // Do we care about offers?  Remember these were vectored directly at our MAC
  // and if we got this far (we're not promiscous), so this shit was directed to us.
  if (! (dhcp->opcode == DHCP_OPTION_OFFER))
    return;

  if(!NIFT_ipsystem.configured) {
    
    // Immediately grab the IP address (this is set from the BOOTP and is not technically DHCP)
    NIFT_ipsystem.ip = Xil_Ntohl(dhcp->yiaddr);
    NIFT_ipsystem.dhcpserver = Xil_Ntohl(dhcp->siaddr);
  }
  
  // Try to parse the messages to see what we are doing
  ptr = dhcp->bp_options;

  if(*ptr != MESSAGE_TYPE_DHCP) {

    // Something is fucked, deconfigure and try again
    NIFT_ipsystem.configured = 0;
    return;
  }

  // Advance to the next field
  ++ptr;

  // OFFER, ACK, or NAK? 
  switch(*ptr) {

  case DHCP_OPTION_OFFER:
    // Okay, this was the server's offering.
    // Try to move into the confirmation phase
    NIFT_ipsystem.configured = 1;
    dhcp_request();
    return;

  case DHCP_OPTION_DECLINE:
  case DHCP_OPTION_NAK:
    // We were too slow on the draw
    // Restart the configuration process
    NIFT_ipsystem.configured = 0;
    return;

  case DHCP_OPTION_ACK:
    // Okay, this is the real deal guys.
    // We finally got our legit IP address.
    // We are a real human now.
    // We can  b r e e d.
    ++ptr;

    // Only need to parse this subset, because this is what we asked for.
    while(NIFT_ipsystem.configured < 2) {

      switch(*ptr) {

      case MESSAGE_TYPE_PAD:
	++ptr;
	break;
	
      case MESSAGE_TYPE_ROUTER:
	++ptr;
        NIFT_ipsystem.gateway = *((u32 *)ptr);
	ptr += 4;
	break;

      case MESSAGE_TYPE_REQ_SUBNET_MASK:
	++ptr;
	NIFT_ipsystem.subnet_mask = *((u32 *)ptr);
	ptr += 4;
	break;

      case MESSAGE_TYPE_END:
	NIFT_ipsystem.configured = 2;
	break;	
      }
    }
    break;
  default:
    // If we're getting anything else at this point, just try again
    NIFT_ipsystem.configured = 0;
    break;
  }
}

/*
 * UDP packet handler
 */
static void udp_input(struct udphdr * udp_packet) {
  
  /* Check if there is a response from DHCP server by checking the source Port */

  // We push to dhcp processing the data minus the udp header
  if (Xil_Ntohs(udp_packet->uh_sport) == DHCP_SERVER_PORT)
    dhcp_input((dhcp_t *)((char *)udp_packet + sizeof(struct udphdr)));
  //  else
  //  print("Dropped non-dhcp packet\n");
}

/*
 * IP Packet handler
 */
static void ip_input(struct ip * ip_packet) {

  // We push to udp processing the data minus the ip header
  if (ip_packet->ip_p == IPPROTO_UDP)
    udp_input((struct udphdr *)((char *)ip_packet + sizeof(struct ip)));
}

static void arp_input(struct arphdr *arp_packet) {
  
  
}

/*
 * Ethernet packet handler
 */
static void ether_input(const u8 *frame) {

  // We cast as ether header, so that we can offset into the first bytes.
  struct ether_header *eframe = (struct ether_header *)frame;
  ushort ethertype;
  
  ethertype = Xil_Htons(eframe->ether_type);

  switch(ethertype) {
    
  case ETHERTYPE_IP:
    ip_input((struct ip *)(frame + sizeof(struct ether_header)));
    break;
    //  case ETHERTYPE_ARP:
    // arp_input((struct arphdr *)(frame + sizeof(struct ether_header)));
    // break;
  default:
    break; 
  }
}

/*
 * Ethernet output handler - Fills appropriate bytes in ethernet header
 */
static void ether_output(u8 *frame, u8 *mac, int len)
{
  //    int result;
    struct ether_header *eframe = (struct ether_header *)frame;

    // Note that this is only for DHCP, since we are broadcasting (-1 rolls over)
    memcpy(eframe->ether_shost, mac, ETHER_ADDR_LEN);
    memset(eframe->ether_dhost, -1,  ETHER_ADDR_LEN);
    eframe->ether_type = Xil_Htons(ETHERTYPE_IP);

    len = len + sizeof(struct ether_header);

    sendFrame(frame, len);
}

/*
 * IP Output handler - Fills appropriate bytes in IP header
 */
static void ip_output(struct ip *ip_header, int *len)
{
    *len += sizeof(struct ip);

    ip_header->ip_hl = 5;
    ip_header->ip_v = 4; //IPVERSION;
    ip_header->ip_tos = 0x10;
    ip_header->ip_len = Xil_Htons(*len);
    ip_header->ip_id = Xil_Htons(0xffff);
    ip_header->ip_off = 0;
    ip_header->ip_ttl = 16;
    ip_header->ip_p = 17; //IPPROTO_UDP;
    ip_header->ip_sum = 0;
    ip_header->ip_src.s_addr = 0x0;
    ip_header->ip_dst.s_addr = 0xffffffff;

    ip_header->ip_sum = in_cksum((unsigned short *) ip_header, sizeof(struct ip));
}

/*
 * UDP output - Fills appropriate bytes in UDP header
 */
static void udp_output(struct udphdr *udp_header, int *len)
{
    if (*len & 1)
        *len += 1;
    *len += sizeof(struct udphdr);

    udp_header->uh_sport = Xil_Htons(DHCP_CLIENT_PORT);
    udp_header->uh_dport = Xil_Htons(DHCP_SERVER_PORT);
    udp_header->uh_ulen = Xil_Htons(*len);
    udp_header->uh_sum = 0;
}

static void dhcp_output(dhcp_t *dhcp, u_int8_t *mac, int *len)
{
    *len += sizeof(dhcp_t);
    memset(dhcp, 0, sizeof(dhcp_t));

    // This is the same for the DISCOVER and REQUEST
    dhcp->opcode = DHCP_BOOTREQUEST;
    dhcp->htype = DHCP_HARDWARE_TYPE_10_EHTHERNET;
    dhcp->hlen = 6;
    memcpy(dhcp->chaddr, mac, DHCP_CHADDR_LEN);

    dhcp->magic_cookie = Xil_Htonl(DHCP_MAGIC_COOKIE);
}

/*
 * Adds DHCP option to the bytestream
 */
static int fill_dhcp_option(u_int8_t *packet, u_int8_t code, u_int8_t *data, u_int8_t len)
{
    packet[0] = code;
    packet[1] = len;
    memcpy(&packet[2], data, len);

    return len + (sizeof(u_int8_t) * 2);
}

/*
 * Fill DHCP options
 */
static int fill_dhcp_discovery_options(dhcp_t *dhcp) {
  
  int len = 0;
  u32 req_ip;
  u8 parameter_req_list[] = {MESSAGE_TYPE_REQ_SUBNET_MASK, MESSAGE_TYPE_ROUTER};
  u8 option;

  option = DHCP_OPTION_DISCOVER;
  len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_DHCP, &option, sizeof(option));
  req_ip = Xil_Htonl(0xc0a8010a);
  len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_REQ_IP, (u8 *)&req_ip, sizeof(req_ip));
  len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_PARAMETER_REQ_LIST, (u8 *)&parameter_req_list, sizeof(parameter_req_list));
  option = 0;
  len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_END, &option, sizeof(option));

  return len;
}

static int fill_dhcp_request_options(dhcp_t *dhcp) {

  int len = 0;
  u8 option;

  // Set up 53: 3
  option = DHCP_OPTION_REQUEST;
  len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_DHCP, &option, sizeof(option));

  // Set up 50
  len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_REQ_IP, (u8 *)&NIFT_ipsystem.ip, sizeof(NIFT_ipsystem.ip));

  // Set up 54
  len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_SELECTED_SERVER, (u8 *)&NIFT_ipsystem.dhcpserver, sizeof(NIFT_ipsystem.dhcpserver));

  // Close the options block
  option = 0; 
  len += fill_dhcp_option(&dhcp->bp_options[len], MESSAGE_TYPE_END, &option, sizeof(option));

  return len;
}

static int dhcp_request(void) {
  
  int len = 0;
  u8 *packet;
  struct udphdr *udp_header;
  struct ip *ip_header;
  dhcp_t *dhcp;

  // Dynamic allocate, because weird af behaviour
  packet = (u8 *)memalign(4, 512 + HAX);
  if(!packet)
    return 1;

  // Now advance by 2 because the 
  packet += HAX;
    
  memset(packet, 0, 512);
    
  // Index into the packet cleverly!
  ip_header = (struct ip *)(packet + sizeof(struct ether_header));
  udp_header = (struct udphdr *)(((char *)ip_header) + sizeof(struct ip));
  dhcp = (dhcp_t *)(((char *)udp_header) + sizeof(struct udphdr));
 
  // Populate DHCP payload
  len = fill_dhcp_request_options(dhcp);
  dhcp_output(dhcp, NIFT_ipsystem.mac, &len);

  // Populate udp header
  udp_output(udp_header, &len);

  // Populate IP header
  ip_output(ip_header, &len);

  // Populate ethernet header and ship
  ether_output(packet, NIFT_ipsystem.mac, len);

  // Clean up
  free(packet - HAX);
  return 0;
}

/*
 * Send DHCP DISCOVERY packet
 */
    		
static int dhcp_discovery(void) {

  int len = 0;

  u8 *packet;
  struct udphdr *udp_header;
  struct ip *ip_header;
  dhcp_t *dhcp;

  // Dynamic allocate, because weird af behaviour
  packet = (u8 *)memalign(4, 512 + HAX);
  if(!packet)
    return 1;

  // Now advance by 2 because the 
  packet += HAX;
    
  memset(packet, 0, 512);
    
  // Index into the packet cleverly!
  ip_header = (struct ip *)(packet + sizeof(struct ether_header));
  udp_header = (struct udphdr *)(((char *)ip_header) + sizeof(struct ip));
  dhcp = (dhcp_t *)(((char *)udp_header) + sizeof(struct udphdr));
 
  // Populate DHCP payload
  len = fill_dhcp_discovery_options(dhcp);
  dhcp_output(dhcp, NIFT_ipsystem.mac, &len);

  // Populate udp header
  udp_output(udp_header, &len);

  // Populate IP header
  ip_output(ip_header, &len);

  // Populate ethernet header and ship
  ether_output(packet, NIFT_ipsystem.mac, len);

  // Clean up
  free(packet - HAX);
  return 0;
}

int main(void) {
  
  int result;
  
  // Set up cache for incoming ethernet frames
  initMemory();
    
  /* Get the MAC address of the interface */
  result = get_mac_address(NIFT_ipsystem.mac);

  // If this doesn't work, something is badly broken with the IOmodule.
  // Just die.
  if (result)
    return;
    
  // Get on the intarwebs
  while(1) {

    // Send DHCP DISCOVERY packet
    if(!NIFT_ipsystem.configured) {
	
      result = dhcp_discovery();
      if(result)
	break;
    }
      
    // Intake 10 frames and try to complete the negotiation
    // This should be changed to a timeout...
    result = 10;
    while(NIFT_ipsystem.configured < 2 && --result > 0) {
      NIFT_intakeFrame();
      ether_input(gInboundData);
      resetFrame();
    }
      
    // We didn't complete the negotiation.  Try again with another offer.
    if(NIFT_ipsystem.configured < 2) {
      sleep(5);
      NIFT_ipsystem.configured = 0;
    }
    else
      break;
  }

  // We escaped the configuration loop, so we're online.
  while(1) {

    // Process frames
    NIFT_intakeFrame();
    ether_input(gInboundData);
    resetFrame();
  }
  
  // Clean up the frame
  free(gInboundData - 2);
}
